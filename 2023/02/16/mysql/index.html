<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="体系架构从上往下看，依次会分为网络连接层、系统服务层、存储引擎层、以及文件系统层，往往编写SQL后，都会遵守着MySQL的这个架构往下走。  网络连接层：主要是指数据库连接池，会负责处理所有客户端接入的工作。 系统服务层：主要包含SQL接口、解析器、优化器以及缓存缓冲区四块区域。 存储引擎层：这里是指MySQL支持的各大存储引擎，如InnoDB、MyISAM等。 文件系统层：涵盖了所有的日志，以及">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql">
<meta property="og:url" content="http://example.com/2023/02/16/mysql/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="体系架构从上往下看，依次会分为网络连接层、系统服务层、存储引擎层、以及文件系统层，往往编写SQL后，都会遵守着MySQL的这个架构往下走。  网络连接层：主要是指数据库连接池，会负责处理所有客户端接入的工作。 系统服务层：主要包含SQL接口、解析器、优化器以及缓存缓冲区四块区域。 存储引擎层：这里是指MySQL支持的各大存储引擎，如InnoDB、MyISAM等。 文件系统层：涵盖了所有的日志，以及">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/02/16/mysql/architecture.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1664346449588-e4f2ab02-8946-4250-9392-d9ff7f556c13.webp#averageHue=%230e0e0e&clientId=u7dcfd29b-664d-4&errorMessage=unknown%20error&from=paste&id=ufbbccec1&originHeight=362&originWidth=893&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=u4ff962bf-9152-4b53-84a2-9dbc8af034f&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1664336883154-387ff267-7d33-43c5-a7df-0fc67d9f1130.webp#averageHue=%230f0f0f&clientId=u7dcfd29b-664d-4&errorMessage=unknown%20error&from=paste&id=uf1ffba60&originHeight=336&originWidth=573&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=u4180df32-91fc-4da9-ae7b-403dc636f6e&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/32672172/1665714154894-9443e68d-4d4b-4bda-bf0a-cbda0be8915e.png#averageHue=%23f0efee&clientId=u7af53c96-7102-4&from=paste&id=u9e5f021a&name=image.png&originHeight=667&originWidth=856&originalType=url&ratio=1&rotation=0&showTitle=false&size=103514&status=done&style=none&taskId=uab6c995b-49f1-4c2e-afd6-d256dffc347&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1664347295859-2dee19a2-4908-4cb5-a23a-97a029a25348.webp#averageHue=%23fbfbfb&clientId=u7dcfd29b-664d-4&errorMessage=unknown%20error&from=paste&id=u3882d1df&originHeight=323&originWidth=898&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=u7739f7a1-59a5-4a98-a3af-8c1acf48405&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1664347394731-da937c7d-9183-487f-8a10-6fdc9c301004.webp#averageHue=%23fbfbfb&clientId=u7dcfd29b-664d-4&errorMessage=unknown%20error&from=paste&id=u28c375b2&originHeight=270&originWidth=1453&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=u19a071ce-cfbd-4eff-8dc7-1cddeabd4cb&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1664347616845-06f5bd10-4ecb-4a44-b06e-1267b0088cb6.webp#averageHue=%2389c68b&clientId=u7dcfd29b-664d-4&errorMessage=unknown%20error&from=paste&id=ua11042d8&originHeight=690&originWidth=738&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=ufbb0401f-7e14-470e-9c30-ccc6cf02a60&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1664347760936-42a304a3-a38e-4f03-8f8d-1e934301d874.webp#averageHue=%2387c68a&clientId=u7dcfd29b-664d-4&errorMessage=unknown%20error&from=paste&id=uea83a672&originHeight=822&originWidth=848&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=ufc0d7f6f-7286-436b-9a75-df089eee537&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1666247009380-08318bd1-1a3b-438c-87f4-44c8ffe6df4a.webp#averageHue=%23d9e0d4&clientId=u7fc509b4-3004-4&from=paste&id=u4e01cef8&originHeight=83&originWidth=221&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6f5bfa82-db0f-4fff-8d73-361954f76ca&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1666247009481-8ff1f277-75bf-465b-b94a-e2dca84a4bb3.webp#averageHue=%23e9e9e3&clientId=u7fc509b4-3004-4&from=paste&id=ue1f8a100&originHeight=104&originWidth=207&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2332b320-e5a4-4076-b752-510596ce85a&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1663575821046-c0f47d29-10e3-4ae7-bcb8-f907e97e74b2.webp#averageHue=%23e5e5e5&clientId=ue3005542-8581-4&errorMessage=unknown%20error&from=paste&id=u13e41e4d&originHeight=427&originWidth=525&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=u05a05504-d3ff-4257-95e0-2ea49ca03c9&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1663575872435-0bbdcd4d-3478-4548-b291-70c56a2b4c64.webp#averageHue=%23ebebeb&clientId=ue3005542-8581-4&errorMessage=unknown%20error&from=paste&id=uf107a7d0&originHeight=323&originWidth=523&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=u5ef27353-2ccc-4002-90cf-691988c83ec&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1663576162781-158fc935-9a38-4a71-a47d-af728ced8d78.webp#averageHue=%23f6f6f3&clientId=ue3005542-8581-4&errorMessage=unknown%20error&from=paste&id=ub4067eda&originHeight=376&originWidth=813&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=u0eea0b98-a3a2-4e2d-b34d-3fd742b3bcd&title=">
<meta property="article:published_time" content="2023-02-16T03:46:36.000Z">
<meta property="article:modified_time" content="2023-02-16T05:38:07.000Z">
<meta property="article:author" content="Kevin Chen">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/02/16/mysql/architecture.png">

<link rel="canonical" href="http://example.com/2023/02/16/mysql/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>mysql | Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">aaaa</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/16/mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kevin Chen">
      <meta itemprop="description" content="bbbbbb">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          mysql
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-16 11:46:36 / 修改时间：13:38:07" itemprop="dateCreated datePublished" datetime="2023-02-16T11:46:36+08:00">2023-02-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h2><p><img src="/2023/02/16/mysql/architecture.png" alt="architecture.png"><br>从上往下看，依次会分为网络连接层、系统服务层、存储引擎层、以及文件系统层，往往编写SQL后，都会遵守着MySQL的这个架构往下走。</p>
<ul>
<li>网络连接层：主要是指数据库连接池，会负责处理所有客户端接入的工作。</li>
<li>系统服务层：主要包含SQL接口、解析器、优化器以及缓存缓冲区四块区域。</li>
<li>存储引擎层：这里是指MySQL支持的各大存储引擎，如InnoDB、MyISAM等。</li>
<li>文件系统层：涵盖了所有的日志，以及数据、索引文件，位于系统硬盘上。</li>
</ul>
<h3 id="网络连接层"><a href="#网络连接层" class="headerlink" title="网络连接层"></a>网络连接层</h3><p>MySQL连接管理器线程负责处理服务器侦听的网络接口上的客户端连接请求。连接管理器线程将每个客户端连接与专用于它的线程相关联，以处理该连接的身份验证和请求处理。<br>连接管理线程在必要时创建一个新线程，但是会先尝试避免这样做，MySQL连接管理器线程首先会查看线程缓存是否包含空闲可用于连接的线程，如果有，则从线程缓存中选取一个空闲的线程分配给客户端，如果没有，则重新创建一个线程。当连接结束时，如果缓存未满，则其线程返回到线程缓存中，用于下次使用。<br>在这种连接线程模型中，存在与当前连接的客户端一样多的线程，这在服务器工作负载高还必须以处理大量的连接时具有一些缺点<br>线程状态：可以通过show processlist;命令查询所有正在运行的线程。<br><img src="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1664346449588-e4f2ab02-8946-4250-9392-d9ff7f556c13.webp#averageHue=%230e0e0e&clientId=u7dcfd29b-664d-4&errorMessage=unknown%20error&from=paste&id=ufbbccec1&originHeight=362&originWidth=893&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=u4ff962bf-9152-4b53-84a2-9dbc8af034f&title="></p>
<h4 id="客户端连接池"><a href="#客户端连接池" class="headerlink" title="客户端连接池"></a>客户端连接池</h4><h4 id="数据库连接数"><a href="#数据库连接数" class="headerlink" title="数据库连接数"></a>数据库连接数</h4><p>连接池的最大线程数可以通过参数max-connections来控制，如果到来的客户端连接超出该值时，新到来的连接都会被拒绝，关于最大连接数的一些命令主要有两条：</p>
<ol>
<li>show variables like ‘%max_connections%’;：查询目前DB的最大连接数。</li>
<li>set GLOBAL max_connections &#x3D; 200;：修改数据库的最大连接数为指定值</li>
</ol>
<p>对于不同的机器配置，可以适当的调整连接池的最大连接数大小，以此可以在一定程度上提升数据库的性能。</p>
<h4 id="数据库线程池"><a href="#数据库线程池" class="headerlink" title="数据库线程池"></a>数据库线程池</h4><p>MySQL本身还会对客户端线程数统计，对于这点可以通过命令show status like “Threads%”;查询：<br><img src="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1664336883154-387ff267-7d33-43c5-a7df-0fc67d9f1130.webp#averageHue=%230f0f0f&clientId=u7dcfd29b-664d-4&errorMessage=unknown%20error&from=paste&id=uf1ffba60&originHeight=336&originWidth=573&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=u4180df32-91fc-4da9-ae7b-403dc636f6e&title="><br>其中各个字段的释义如下：<br>Threads_cached：目前空闲的数据库连接数。<br>Threads_connected：当前数据库存活的数据库连接数。<br>Threads_created：MySQL-Server运行至今，累计创建的连接数。<br>Threads_running：目前正在执行的数据库连接数。<br>对于几个字段很容易理解，额外要说明的一点是Threads_cached这个字段，从名称上来看，似乎跟缓存有关系，其实也没错，因为这里是有一个数据库内部的优化机制。当一个客户端连接断开后，对于数据库连接却不会立马销毁，而是会先放入到一个缓存连接池当中。这样就能在下次新连接到来时，省去了创建线程、分配栈空间等一系列动作，但这个值不会是无限大的，一般都在32左右。</p>
<h3 id="系统服务层"><a href="#系统服务层" class="headerlink" title="系统服务层"></a>系统服务层</h3><h4 id="SQL接口"><a href="#SQL接口" class="headerlink" title="SQL接口"></a>SQL接口</h4><p>其实主要作用就是负责处理客户端的SQL语句，当客户端连接建立成功之后，会接收客户端的SQL命令，比如DML、DDL语句以及存储过程、触发器等，当收到SQL语句时，SQL接口会将其分发给其他组件，然后等待接收执行结果的返回，最后会将其返回给客户端。</p>
<h4 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h4><p>主要是为了验证SQL语句是否正确，以及将SQL语句解析成MySQL能看懂的机器码指令</p>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>优化器的主要职责在于生成执行计划，比如选择最合适的索引，选择最合适的join方式等，最终会选择出一套最优的执行计划。<br>优化器生成了执行计划后，维护当前连接的线程会负责根据计划去执行SQL，这个执行的过程实际上是在调用存储引擎所提供的API</p>
<h4 id="缓存-amp-缓冲"><a href="#缓存-amp-缓冲" class="headerlink" title="缓存&amp;缓冲"></a>缓存&amp;缓冲</h4><p>在高版本的MySQL中，移除了查询缓存区，毕竟命中率不高，而且查询缓存这一步还要带来额外开销，同时一般程序都会使用Redis做一次缓存，因此结合多方面的原因就移除了查询缓存的设计。<br>写入缓冲，这也是我说的比较有趣的点，缓冲区的设计主要是：<strong>为了通过内存的速度来弥补磁盘速度较慢对数据库造成的性能影响</strong>。在数据库中读取某页数据操作时，会先将从磁盘读到的页存放在缓冲区中，后续操作相同页的时候，可以基于内存操作<br>一般来说，当你对数据库进行写操作时，都会先从缓冲区中查询是否有你要操作的页，如果有，则直接对内存中的数据页进行操作（例如修改、删除等），对缓冲区中的数据操作完成后，会直接给客户端返回成功的信息，然后MySQL会在后台利用一种名为Checkpoint的机制，将内存中更新的数据刷写到磁盘</p>
<h3 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h3><p>存储引擎也可以理解成MySQL最重要的一层，在前面的服务层中，聚集了MySQL所有的核心逻辑操作，而引擎层则负责具体的数据操作以及执行工作。<br>MySQL目前有非常多的存储引擎可选择，其中最为常用的则是InnoDB与MyISAM引擎.</p>
<h4 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h4><h5 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h5><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32672172/1665714154894-9443e68d-4d4b-4bda-bf0a-cbda0be8915e.png#averageHue=%23f0efee&clientId=u7af53c96-7102-4&from=paste&id=u9e5f021a&name=image.png&originHeight=667&originWidth=856&originalType=url&ratio=1&rotation=0&showTitle=false&size=103514&status=done&style=none&taskId=uab6c995b-49f1-4c2e-afd6-d256dffc347&title=" alt="image.png"></p>
<h6 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h6><p>InnoDB缓冲池是一个内存区域，用于保存表、索引和其他辅助缓冲区的缓存InnoDB数据。为了提高高容量读取操作的效率，缓冲池被划分为可能包含多行的页。为了提高缓存管理的效率，缓冲池被实现为页面的链接列表；使用LRU算法的变体，很少使用的数据从缓存中老化</p>
<ul>
<li>在具有大量内存的系统上，可以通过将缓冲池划分为多个缓冲池实例来提高并发性。innodb_buffer_pool_instances系统变量定义缓冲池实例的数量。</li>
<li>缓冲池太大可能会由于内存竞争而导致交换。</li>
<li>缓冲池太小可能会导致过度搅动，因为页面只在很短时间后才从缓冲池中刷新。</li>
</ul>
<h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><h6 id="特性-ACID"><a href="#特性-ACID" class="headerlink" title="特性(ACID)"></a>特性(ACID)</h6><ul>
<li>原子性 数据的操作基于事务，要不成功要么失败，（undo日志保证）</li>
<li>一致性 事务开始前和结束后，数据库的完整性约束没有被破坏，其他特性保证</li>
<li>隔离性 一个事务的执行不能被其它事务干扰，(MVCC保证)</li>
<li>持久性 指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的，（redo日志保证）<ul>
<li>innodb redo log 写盘，innodb 事务进入prepare 状态</li>
<li>如果前面prepare成功，binlog写盘，再继续将事务日志持久化到binlog,那么innodb 事务则进入commit 状态（redo log 里面写一个commit记录）</li>
</ul>
</li>
</ul>
<h6 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h6><ol>
<li>分类</li>
</ol>
<ul>
<li>undo</li>
</ul>
<p>InnoDB实现回滚，靠的是undo log：当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子</p>
<ul>
<li>redo</li>
</ul>
<p>重做日志至关重要，因为它们记录了对于InnoDB存储引擎的事务日志</p>
<ul>
<li><p>binlog</p>
<p>   关于二进制日志，它记录了数据库所有执行的DDL和DML语句（除了数据查询语句select、show等），以事件形式记录并保存在二进制文件中</p>
</li>
</ul>
<ol start="2">
<li><strong>既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：</strong></li>
</ol>
<ul>
<li>刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。</li>
<li>刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少。</li>
</ul>
<h6 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h6><ol>
<li>READ UNCOMMITTED（读未提交数据）</li>
<li>READ COMMITTED（读已提交数据）</li>
<li>REPEATABLE READ（可重复读）</li>
<li>SERIALIZABLE（串行化）</li>
<li>查询方法：MySQL 8.0 该命令改为SELECT @@transaction_isolation;</li>
</ol>
<h6 id="并发事务产生问题"><a href="#并发事务产生问题" class="headerlink" title="并发事务产生问题"></a>并发事务产生问题</h6><ol>
<li><p>脏读，读到未提交的数据</p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td></td>
<td><strong>开始事务</strong></td>
</tr>
<tr>
<td>T2</td>
<td><strong>开始事务</strong></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>查询账户余额为1000元</td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>取出500元把余额改为500元</td>
</tr>
<tr>
<td>T5</td>
<td>查询账户余额为500元（脏读）</td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><strong>撤销事务</strong>，余额恢复为1000元</td>
</tr>
<tr>
<td>T7</td>
<td>存入100元把余额改为600元</td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td><strong>提交事务</strong></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>不可重复度（当前读写），读到已经提交更新的数据，但一个事务范围内两个相同的查询却返回了不同数据。</p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td></td>
<td><strong>开始事务</strong></td>
</tr>
<tr>
<td>T2</td>
<td><strong>开始事务</strong></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>查询账户余额为1000元</td>
</tr>
<tr>
<td>T4</td>
<td>查询账户余额为1000元</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>取出100元把余额改为900元</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><strong>提交事务</strong></td>
</tr>
<tr>
<td>T7</td>
<td>查询账户余额为900元（与T4读取的一不一致，不可重复读）</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>幻读（快照读），读到已提交插入数据，幻读与不可重复读类似，幻读是查询到了另一个事务已提交的新插入数据，而不可重复读是查询到了另一个事务已提交的更新数据。</p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td></td>
<td><strong>开始事务</strong></td>
</tr>
<tr>
<td>T2</td>
<td><strong>开始事务</strong></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td>统计用户Z总存款数为1000元</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>新增Z的一个存款账号，存款100元</td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td><strong>提交事务</strong></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T7</td>
<td>再次统计用户Z总存款数为1100元（与T4读取的一不一致，幻读）</td>
<td></td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="文件系统层"><a href="#文件系统层" class="headerlink" title="文件系统层"></a>文件系统层</h3><p>这一层则是MySQL数据库的基础，本质上就是基于机器物理磁盘的一个文件系统，其中包含了配置文件、库表结构文件、数据文件、索引文件、日志文件等各类MySQL运行时所需的文件，这一层的功能比较简单，也就是与上层的存储引擎做交互，负责数据的最终存储与持久化工作<br>这一层主要可分为两个板块：①日志板块。②数据板块。</p>
<h4 id="日志板块"><a href="#日志板块" class="headerlink" title="日志板块"></a>日志板块</h4><p>  在MySQL中主要存在七种常用的日志类型，如下：</p>
<ul>
<li>binlog二进制日志，主要记录MySQL数据库的所有写操作（增删改）。</li>
<li>redo-log重做&#x2F;重写日志，MySQL崩溃时，对于未落盘的操作会记录在这里面，用于重启时重新落盘（InnoDB专有的）。</li>
<li>undo-logs撤销&#x2F;回滚日志：记录事务开始前[修改数据]的备份，用于回滚事务。</li>
<li>error-log：错误日志：记录MySQL启动、运行、停止时的错误信息。</li>
<li>general-log常规日志，主要记录MySQL收到的每一个查询或SQL命令。</li>
<li>slow-log：慢查询日志，主要记录执行时间较长的SQL。</li>
<li>relay-log：中继日志，主要用于主从复制做数据拷贝。</li>
</ul>
<h4 id="数据板块"><a href="#数据板块" class="headerlink" title="数据板块"></a>数据板块</h4><p>MySQL的所有数据最终都会落盘（写入到磁盘），而不同的数据在磁盘空间中，存储的格式也并不相同，因此再列举出一些MySQL中常见的数据文件类型：</p>
<ul>
<li>db.opt文件：主要记录当前数据库使用的字符集和验证规则等信息。</li>
<li>.frm文件：存储表结构的元数据信息文件，每张表都会有一个这样的文件。</li>
<li>.MYD文件：用于存储表中所有数据的文件（MyISAM引擎独有的）。</li>
<li>.MYI文件：用于存储表中索引信息的文件（MyISAM引擎独有的）。</li>
<li>.ibd文件：用于存储表数据和索引信息的文件（InnoDB引擎独有的）。</li>
<li>.ibdata文件：用于存储共享表空间的数据和索引的文件（InnoDB引擎独有）。</li>
<li>.ibdata1文件：这个主要是用于存储MySQL系统（自带）表数据及结构的文件。</li>
<li>.ib_logfile0&#x2F;.ib_logfile1文件：用于故障数据恢复时的日志文件。</li>
<li>.cnf&#x2F;.ini：MySQL的配置文件，Windows下是.ini，其他系统大多为.cnf。</li>
<li>……</li>
</ul>
<h2 id="优化分析"><a href="#优化分析" class="headerlink" title="优化分析"></a>优化分析</h2><h3 id="SQL执行过程"><a href="#SQL执行过程" class="headerlink" title="SQL执行过程"></a>SQL执行过程</h3><p>一条完整的SQL就诞生了，为了SQL能够正常执行，首先会先去获取一个数据库连接对象，上篇关于MySQL的架构篇曾聊到过，MySQL连接层中会维护着一个名为「连接池」的玩意儿，但相信大家也都接触过「数据库连接池」这个东西，比如Java中的C3P0、Druid、DBCP….等各类连接池。</p>
<h4 id="一条SQL执行前会经历的过程"><a href="#一条SQL执行前会经历的过程" class="headerlink" title="一条SQL执行前会经历的过程"></a>一条SQL执行前会经历的过程</h4><h5 id="数据库连接池的必要性"><a href="#数据库连接池的必要性" class="headerlink" title="数据库连接池的必要性"></a>数据库连接池的必要性</h5><h5 id="SQL执行前会发生的事情"><a href="#SQL执行前会发生的事情" class="headerlink" title="SQL执行前会发生的事情"></a>SQL执行前会发生的事情</h5><p>当完整的SQL生成后，会先去连接池中尝试获取一个连接对象，那接下来会发生什么事情呢？如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1664347295859-2dee19a2-4908-4cb5-a23a-97a029a25348.webp#averageHue=%23fbfbfb&clientId=u7dcfd29b-664d-4&errorMessage=unknown%20error&from=paste&id=u3882d1df&originHeight=323&originWidth=898&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=u7739f7a1-59a5-4a98-a3af-8c1acf48405&title="><br>当尝试从java连接池中获取连接时，如果此时连接池中有空闲连接，可以直接拿到复用，但如果没有，则要先判断一下当前池中的连接数是否已达到最大连接数，如果连接数已经满了，当前线程则需要等待其他线程释放连接对象，没满则可以直接再创建一个新的数据库连接使用。<br>MySQL中创建了一个客户端会话，然后会发生下图一系列工作<br><img src="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1664347394731-da937c7d-9183-487f-8a10-6fdc9c301004.webp#averageHue=%23fbfbfb&clientId=u7dcfd29b-664d-4&errorMessage=unknown%20error&from=paste&id=u28c375b2&originHeight=270&originWidth=1453&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=u19a071ce-cfbd-4eff-8dc7-1cddeabd4cb&title="></p>
<ul>
<li>①首先会验证客户端的用户名和密码是否正确： <ul>
<li>如果用户名不存在或密码错误，则抛出1045的错误码及错误信息。</li>
<li>如果用户名和密码验证通过，则进入第②步。</li>
</ul>
</li>
<li>②判断MySQL连接池中是否存在空闲线程： <ul>
<li>存在：直接从连接池中分配一条空闲线程维护当前客户端的连接。</li>
<li>不存在：创建一条新的工作线程（映射内核线程、分配栈空间….）。</li>
</ul>
</li>
<li>③工作线程会先查询MySQL自身的用户权限表，获取当前登录用户的权限信息并授权。</li>
</ul>
<h4 id="一条SQL语句在数据库中是如何执行的？"><a href="#一条SQL语句在数据库中是如何执行的？" class="headerlink" title="一条SQL语句在数据库中是如何执行的？"></a>一条SQL语句在数据库中是如何执行的？</h4><p> 经过连接层的一系列工作后，接着客户端会将要执行的SQL语句通过连接发送过来，然后会进行MySQL服务层进行处理，不过根据用户的操作不同，MySQL执行SQL语句时也会存在些许差异，这里是指读操作和写操作，两者SQL的执行过程并不相同，下面先来看看select语句的执行过程。</p>
<h5 id="一条查询SQL的执行过程"><a href="#一条查询SQL的执行过程" class="headerlink" title="一条查询SQL的执行过程"></a>一条查询SQL的执行过程</h5><p>SQL执行的完整流程图，后续再逐步分析每个过程：<br><img src="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1664347616845-06f5bd10-4ecb-4a44-b06e-1267b0088cb6.webp#averageHue=%2389c68b&clientId=u7dcfd29b-664d-4&errorMessage=unknown%20error&from=paste&id=ua11042d8&originHeight=690&originWidth=738&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=ufbb0401f-7e14-470e-9c30-ccc6cf02a60&title="></p>
<h5 id="一条写入SQL的执行过程"><a href="#一条写入SQL的执行过程" class="headerlink" title="一条写入SQL的执行过程"></a>一条写入SQL的执行过程</h5><p><img src="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1664347760936-42a304a3-a38e-4f03-8f8d-1e934301d874.webp#averageHue=%2387c68a&clientId=u7dcfd29b-664d-4&errorMessage=unknown%20error&from=paste&id=uea83a672&originHeight=822&originWidth=848&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=ufc0d7f6f-7286-436b-9a75-df089eee537&title="></p>
<h4 id="一条SQL执行完成后是如何返回的？"><a href="#一条SQL执行完成后是如何返回的？" class="headerlink" title="一条SQL执行完成后是如何返回的？"></a>一条SQL执行完成后是如何返回的？</h4><h5 id="读类型的SQL返回"><a href="#读类型的SQL返回" class="headerlink" title="读类型的SQL返回"></a>读类型的SQL返回</h5><h5 id="写类型的SQL返回"><a href="#写类型的SQL返回" class="headerlink" title="写类型的SQL返回"></a>写类型的SQL返回</h5><h3 id="MVCC概念以及底层原理"><a href="#MVCC概念以及底层原理" class="headerlink" title="MVCC概念以及底层原理"></a>MVCC概念以及底层原理</h3><p>MVCC （multiversion concurrency control），多版本并发控制，主要是通过在每一行记录中增加三个字段，与 undo log 中相关记录配合使用，同时加上可见性算法，使得各个事务可以在不加锁的情况下能够同时地读取到某行记录上的准确值（这个值对不同的事务而言可能是不同的）。使用 MVCC，在不加锁的情况下也能读取到准确的数据，大大提高了并发效率。</p>
<h4 id="MVCC能解决幻读吗"><a href="#MVCC能解决幻读吗" class="headerlink" title="MVCC能解决幻读吗"></a>MVCC能解决幻读吗</h4><p>测试前数据：<br><img src="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1666247009380-08318bd1-1a3b-438c-87f4-44c8ffe6df4a.webp#averageHue=%23d9e0d4&clientId=u7fc509b4-3004-4&from=paste&id=u4e01cef8&originHeight=83&originWidth=221&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6f5bfa82-db0f-4fff-8d73-361954f76ca&title="></p>
<table>
<thead>
<tr>
<th>事务 1</th>
<th>事务 2</th>
</tr>
</thead>
<tbody><tr>
<td>begin</td>
<td>begin</td>
</tr>
<tr>
<td>select * from dept</td>
<td></td>
</tr>
<tr>
<td>-</td>
<td>insert into dept(name) values(“研发部”)</td>
</tr>
<tr>
<td>-</td>
<td>commit</td>
</tr>
<tr>
<td>update dept set name&#x3D;”财务部”</td>
<td></td>
</tr>
<tr>
<td>commit</td>
<td></td>
</tr>
</tbody></table>
<p>根据上面的结果我们期望的结果是这样的：<br>id  name 1   财务部 2   研发部 复制代码<br>但是实际上我们的经过是：<br><img src="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1666247009481-8ff1f277-75bf-465b-b94a-e2dca84a4bb3.webp#averageHue=%23e9e9e3&clientId=u7fc509b4-3004-4&from=paste&id=ue1f8a100&originHeight=104&originWidth=207&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2332b320-e5a4-4076-b752-510596ce85a&title="><br>本来我们希望得到的结果只是第一条数据的部门改为财务，但是结果确实两条数据都被修改了。这种结果告诉我们其实在MySQL可重复读的隔离级别中并不是完全解决了幻读的问题，而是解决了读数据情况下的幻读问题。而对于修改的操作依旧存在幻读问题，就是说MVCC对于幻读的解决时不彻底的。</p>
<h4 id="select-快照读"><a href="#select-快照读" class="headerlink" title="select 快照读"></a>select 快照读</h4><p>当执行select操作是innodb默认会执行快照读，会记录下这次select后的结果，之后select 的时候就会返回这次快照的数据，即使其他事务提交了不会影响当前select的数据，这就实现了可重复读了。快照的生成当在第一次执行select的时候，也就是说假设当A开启了事务，然后没有执行任何操作，这时候B insert了一条数据然后commit,这时候A执行 select，那么返回的数据中就会有B添加的那条数据。之后无论再有其他事务commit都没有关系，因为快照已经生成了，后面的select都是根据快照来的。</p>
<h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>对于会对数据修改的操作(update、insert、delete)都是采用当前读的模式。在执行这几个操作时会读取最新的记录，即使是别的事务提交的数据也可以查询到。假设要update一条记录，但是在另一个事务中已经delete掉这条数据并且commit了，如果update就会产生冲突，所以在update的时候需要知道最新的数据。也正是因为这样所以才导致上面我们测试的那种情况。<br>select的当前读需要手动的加锁：<br>select * from table where ? lock in share mode; select * from table where ? for update;</p>
<h4 id="MVCC多版本并发控制依赖的三个组件重要概念"><a href="#MVCC多版本并发控制依赖的三个组件重要概念" class="headerlink" title="MVCC多版本并发控制依赖的三个组件重要概念"></a>MVCC多版本并发控制依赖的三个组件重要概念</h4><h4 id="MVCC实现多版本并发控制的原理"><a href="#MVCC实现多版本并发控制的原理" class="headerlink" title="MVCC实现多版本并发控制的原理"></a>MVCC实现多版本并发控制的原理</h4><p>MVCC多版本并发控制实现的原理就是通过InnoDB表的隐藏字段、undo log版本链、ReadView读视图配合来实现。</p>
<h4 id="不同隔离级别下MVCC实现并发控制的原理"><a href="#不同隔离级别下MVCC实现并发控制的原理" class="headerlink" title="不同隔离级别下MVCC实现并发控制的原理"></a>不同隔离级别下MVCC实现并发控制的原理</h4><h5 id="RC隔离级别下"><a href="#RC隔离级别下" class="headerlink" title="RC隔离级别下"></a>RC隔离级别下</h5><p>在RC隔离级别下，每当执行的SQL是快照读类型的，就会生成一个ReadView读视图，每次生成的ReadView读视图所对应的四个字段值都是不同的，在RC隔离级别下，每次快照读读取的版本数据可能也不相同</p>
<h5 id="RR隔离级别下"><a href="#RR隔离级别下" class="headerlink" title="RR隔离级别下"></a>RR隔离级别下</h5><p>在RR隔离级别下，首次快照读读的版本数据，在后续的快照读中也会复用该数据，做到重复读。<br>m_ids  活跃事务；[100，200，301]<br>max_limit_id  当前最大事务id+1；[302]<br>min_limit_id  当前活跃事务最新事务id；[100]<br>creator_trx_id ReadView创建者的事务ID,当前事务id；[301]<br>如果数据事务的id&lt;min_limit_id ,表明生成该版本的事务在readView之前已经提交，所以该版本当前事务可访问；<br>如果数据事务的id&gt;max_limit_id ,表明生成该版本的事务在readView之后，所以不可以被当前事务访问；<br>如果数据min_limit_id &lt;事务的id&lt;max_limit_id </p>
<ul>
<li>如果m_ids 包含事务的id,则代表readView生成时刻，这个事务还未提交，当事务id&#x3D;当前创建事务的id,表明数据是自己生成的，可见；</li>
<li>如果m_ids 包含事务的id,则代表readView生成时刻，这个事务还未提交.当事务id!&#x3D;当前创建事务的id,不可见</li>
<li>如果m_ids 不包含事务id,则代表readView生成时刻，这个事务已经提交数据可见；</li>
</ul>
<h3 id="LBCC"><a href="#LBCC" class="headerlink" title="LBCC"></a>LBCC</h3><h4 id="MySQL的锁分类"><a href="#MySQL的锁分类" class="headerlink" title="MySQL的锁分类"></a>MySQL的锁分类</h4><h5 id="锁的模式"><a href="#锁的模式" class="headerlink" title="锁的模式"></a>锁的模式</h5><p><img src="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1663575821046-c0f47d29-10e3-4ae7-bcb8-f907e97e74b2.webp#averageHue=%23e5e5e5&clientId=ue3005542-8581-4&errorMessage=unknown%20error&from=paste&id=u13e41e4d&originHeight=427&originWidth=525&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=u05a05504-d3ff-4257-95e0-2ea49ca03c9&title="></p>
<h5 id="锁算法"><a href="#锁算法" class="headerlink" title="锁算法"></a>锁算法</h5><p><img src="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1663575872435-0bbdcd4d-3478-4548-b291-70c56a2b4c64.webp#averageHue=%23ebebeb&clientId=ue3005542-8581-4&errorMessage=unknown%20error&from=paste&id=uf107a7d0&originHeight=323&originWidth=523&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=u5ef27353-2ccc-4002-90cf-691988c83ec&title="></p>
<h4 id="锁的模式-1"><a href="#锁的模式-1" class="headerlink" title="锁的模式"></a>锁的模式</h4><h5 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h5><p>有名读锁，对某一资源加共享锁，自身可以读取该资源，其他人也可以读该资源（可继续加共享锁），但是无法修改，想要修改就必须等所有共享锁都释放完后才能进行</p>
<ul>
<li>加锁 select * from table lock in share mode</li>
<li>释放锁 Commit 、 Rollback</li>
</ul>
<h5 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h5><p>对某一资源加排它锁、自身科技进行增删改查、其他人无法进行任何操作<br>注意：排它锁不能与其他锁并存</p>
<h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><ul>
<li>意向共享锁–Intention Shared Locks 表示事务准备个数据加共享锁之前——前提是获取此表的IS锁</li>
<li>意向排它锁–Intention Exclusive Locks 表示事务准备个数据加排它锁之前——前提是获取此表的IX锁</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6947626257592877064#heading-12">https://juejin.cn/post/6947626257592877064#heading-12</a></p>
<h4 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h4><h5 id="锁的区间"><a href="#锁的区间" class="headerlink" title="锁的区间"></a>锁的区间</h5><p><img src="https://cdn.nlark.com/yuque/0/2022/webp/32672172/1663576162781-158fc935-9a38-4a71-a47d-af728ced8d78.webp#averageHue=%23f6f6f3&clientId=ue3005542-8581-4&errorMessage=unknown%20error&from=paste&id=ub4067eda&originHeight=376&originWidth=813&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=u0eea0b98-a3a2-4e2d-b34d-3fd742b3bcd&title="></p>
<h5 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h5><p>锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持</p>
<h5 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h5><p>锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44300779/article/details/122494022?spm=1001.2014.3001.5501">幻读</a>。在RR隔离级别下都支持。</p>
<h5 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h5><p>行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持</p>
<h4 id="用法分析"><a href="#用法分析" class="headerlink" title="用法分析"></a>用法分析</h4><h5 id="select-for-update"><a href="#select-for-update" class="headerlink" title="select for update"></a>select for update</h5><p>会让select语句产生一个排它锁</p>
<ul>
<li><p>用法1：需要先将数据查询出来，然后再去更新</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from goods <span class="built_in">where</span> <span class="built_in">id</span> = 1 <span class="keyword">for</span> update;</span><br><span class="line">// 检查库存足够代码</span><br><span class="line">update goods <span class="built_in">set</span> stock = stock - 1 <span class="built_in">where</span> <span class="built_in">id</span> = 1;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>
<p>如果不使用for update 在查询后，执行更新前，数据可能被其他事务更改，所以应用for update 先锁住<br>注意事项</p>
</li>
<li><p>select for update会根据where条件来锁多条记录, 根据where条件的字段是不是索引来决定锁定表还是锁定行，同时根据是聚簇索引还是二级索引和查询条件（范围查询还是精确查询）来决定锁定特定的行还是一个范围内的行</p>
</li>
<li><p>当锁定范围的行时会有gap lock和next-key来防止插入新的行</p>
</li>
<li><p>SELECT * FROM information_schema.innodb_trx \G 使用该语句可以查询某个事务锁了几个表，锁了几个行</p>
</li>
</ul>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>死锁是两个或多个事务在同一个资源上相互占用，并请求锁定对方的资源，从而导致循环的现象<br>常见的解决死锁的方法</p>
<ul>
<li>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li>
<li>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</li>
<li>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</li>
</ul>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h3 id="执行计划分析"><a href="#执行计划分析" class="headerlink" title="执行计划分析"></a>执行计划分析</h3><h4 id="EXPLAIN中的列"><a href="#EXPLAIN中的列" class="headerlink" title="EXPLAIN中的列"></a>EXPLAIN中的列</h4><h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h5><p><strong>表示对应行是简单还是复杂的查询。</strong></p>
<ol>
<li>SIMPLE，简单SELECT，查询不包括UNION和子查询。</li>
<li>PRIMARY，查询中若查询包含任何复杂的子部分，最外层的select被标记为PRIMARY。其他部分标记如下： <ol>
<li>SUBQUERY，包含在SELECT子句（不在from子句中）中的子查询的SELECT，结果不依赖于外部查询。</li>
<li>DERIVED，包含在from子句中的子查询中的SELECT。MySQL会递归执行并将结果存放在一个临时表中，也称为派生表，因为该临时表是从子查询中派生来的。</li>
<li>UNION，UNION中的第二个或后面的SELECT。第一个SELECT被标记就好像它以部分外查询来执行，因此第一个SELECT可能显示为PRIMARY。如果UNION被FROM字句中的子查询包含，那么它的第一个SELECT被标记为DERIVED。</li>
<li>UNION RESULT，用来从UNION的匿名临时表中检索结果的SELECT。</li>
</ol>
</li>
</ol>
<p>除了上面这些，SUBQUERY和UNION还可以被标记为DEPENDENT和UNCACHEABLE，DEPENDENT意味着SELECT 依赖与外层查询中发现的数据；UNCACHEABLE意味着SELECT 中的某些特性阻止结果被缓存于一个 Item_cache 中。</p>
<h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p><strong>关联类型，或者说访问类型，该字段表明MySQL决定如何查找表中的行。</strong><br>常用的访问类型如下（性能依次从最差到最优）：</p>
<ol>
<li>ALL：<strong>全表扫描，从头到尾的查找所需要的行</strong>。但仍然存在例外，例如使用了 LIMIT ，或者Extra 列中显示 “Using distinct&#x2F;not exists”。</li>
<li>index：<strong>跟全表扫描一样，只是MySQL扫描表时按照索引次序进行而不是行，主要优点是避免了排序；缺点是要承担按索引次序读取整个表的开销</strong>。这通常意味着如实按照随机次序访问行，开销较大。如果Extra 列中显示 “using index”，说明MySQL正在使用覆盖索引，这样就不需要按索引次序访问每一行数据，开小会少很多。</li>
<li>range：<strong>范围扫描，就是一个有限制的索引扫描，使用一个索引来检索给定范围的行，不需要遍历全部索引</strong>。范围扫描通常出现在between,&gt;,&lt;,&gt;&#x3D;等操作中。in()和OR也会显示范围扫描，但这两者其实是不同的访问类型，性能上也有差异。此类查找的开销根ref索引访问的开销相当。</li>
<li>ref：<strong>索引访问，也叫索引查找</strong>。返回所有匹配某个单个值的行，然而它可能会找到符合条件的多个行。此类索引访问只有当使用<strong>非唯一性索引或者唯一索引的非唯一性前缀</strong>时才会发生。把他叫ref是因为他要和某个参考值相比较。这个参考值或者是一个常数，或者来自多表查询前一个表里的结果值。</li>
<li>eq_ref：使用这种<strong>索引查找</strong>，MySQL清楚的知道<strong>最多只返回一条</strong>符合条件的记录，使用<strong>主键或者唯一值索引</strong>查找时能看到这种方法。MySQL对于这种访问类型的优化做得非常好，因为它知道到无需估计匹配行的范文或者在找到匹配行后再继续查找（因为值不会重复）。</li>
<li>const，system：<strong>当MySQL能对查询的某部分进行优化并将其转换成一个常量时，它就会使用这些访问类型</strong>。比如通过将某一行的主键访问WHERE字句的方式来查询主键：SELECT id from t where id &#x3D; 1。此时MySQL就能把这个查询转换为一个常量。</li>
<li>NULL：<strong>这种访问方式意味着MySQ能在优化阶段分解查询语句，在执行阶段甚至不需要再访问表或者索引</strong>。例如，从一个索引列里选取最小值可以通过单独查询索引来完成，不需要在执行时访问表。</li>
<li>index_merge：<a href="https://link.juejin.cn/?target=https://blog.csdn.net/weixin_43767015/article/details/119461288">索引合并（index merge）</a>**。MySQL5.0之前，一个表一次只能使用一个索引，无法同时使用多个索引分别进行条件扫描。但是从5.1开始，引入了索引合并优化技术，对同一个表可以使用多个索引分别进行条件扫描，然后将它们各自的结果进行合并(intersect&#x2F;union)**。index merge使得我们可以使用到多个索引同时进行扫描，然后将结果进行合并。听起来好像是很好的功能，但是如果出现了 index intersect merge，那么一般同时也意味着我们的索引建立得不太合理，因为 index intersect merge 是可以通过建立复合索引进行更一步优化的。</li>
</ol>
<h5 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h5><p>显示查询可以使用哪些索引，这是基于查询访问的列和使用的比较操作符来判断的。该列表是在优化过程的早期创建的，因此列出来的索引对于后续实际优化过程可能是没有用的。</p>
<h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><p>显示mysql决定采用哪一个索引来优化对该表的访问，如果该索引没有出现在possible_keys列中，那么MySQL选用它是出于另外的原因——例如，它可能选择了一个覆盖索引，哪怕它没有WHERE字句。<br>possible_keys表示哪些索引有助于高效查找，而key表示该索引可以最小化查询成本。<br>如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p>
<h5 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h5><p>这一列展示的是额外信息。常见的重要值如下：</p>
<ol>
<li>Using index：表示MySQL将使用覆盖索引，这发生在对表的请求列都是同一索引的部分的时候，返回的列数据只使用了索引中的信息，而没有再去访问表中的行记录。是性能高的表现。</li>
<li>Using index condition：在5.6版本后加入的新特性索引下推（Index Condition Pushdown，ICP），在索引遍历过程中，对索引中包含的字段先做判断（即使该字段没有使用到索引），直接过滤掉不满足条件的记录，减少回表次数。</li>
<li>Using where：意味着MySQL服务器将在存储引擎检索行后再进行过滤。就是先通过索引读取整行数据，再按 WHRER条件进行检查，符合就留下，不符合就丢弃。查询的列未被索引覆盖。</li>
<li>Using temporary：MySQL需要创建一张临时表来中间结果并进一步处理，比如union、group by、distinct等，出现这种情况一般是要进行优化的，首先是想到用索引来优化。</li>
<li>Using filesort：MySQL会对结果使用一个外部索引排序，而不是按索引次序从表里读取行，即filesort（文件排序）。此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。这种情况下一般也是要考虑使用索引来优化的。filesort有两种，一种是内存排序，一种是磁盘排序，无法得知。</li>
<li>Distinct: 一旦MySQL找到了与行相联合匹配的行，就不再搜索了，常见于关联查询。</li>
<li>No tables used：Query语句中使用from dual 或不含任何from子句。</li>
<li>Using join buffer：使用了连接缓存，join语句用到了缓冲区。</li>
</ol>
<h3 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h3><h4 id="系统层面配置"><a href="#系统层面配置" class="headerlink" title="系统层面配置"></a>系统层面配置</h4><h5 id="服务器硬件"><a href="#服务器硬件" class="headerlink" title="服务器硬件"></a>服务器硬件</h5><h6 id="CPU资源（64位，主频，核心数）"><a href="#CPU资源（64位，主频，核心数）" class="headerlink" title="CPU资源（64位，主频，核心数）"></a>CPU资源（64位，主频，核心数）</h6><ul>
<li>cpu密集型，复杂sql (主频更高)</li>
<li>cpu核心数 ,高并发场景 (核心数优先)</li>
</ul>
<h6 id="Memory资源（主频高，容量大）"><a href="#Memory资源（主频高，容量大）" class="headerlink" title="Memory资源（主频高，容量大）"></a>Memory资源（主频高，容量大）</h6><ul>
<li>内存大小对性能影响</li>
</ul>
<h6 id="磁盘配置"><a href="#磁盘配置" class="headerlink" title="磁盘配置"></a>磁盘配置</h6><ul>
<li>传统磁盘（存储容量，传输速度，访问时间，主轴转速，物理尺寸）</li>
<li>RAID</li>
<li>SSD （大量随机IO，单线程负载io瓶颈）<ul>
<li>增加随机读写性能，</li>
<li>更好支持并发</li>
<li>容易损坏</li>
</ul>
</li>
<li>SAN&#x2F;NAS 网络存储</li>
</ul>
<h5 id="服务器系统"><a href="#服务器系统" class="headerlink" title="服务器系统"></a>服务器系统</h5><h6 id="centos系统参数"><a href="#centos系统参数" class="headerlink" title="centos系统参数"></a>centos系统参数</h6><ol>
<li>内核相关参数（&#x2F;etc&#x2F;sysctl.conf）<ol>
<li>tcp网络参数</li>
</ol>
<ul>
<li>net.core.somaxconn &#x3D; 65535</li>
<li>net.core.netdev_max_backlog &#x3D; 65536</li>
<li>net.ipv4.tcp_max_syn_backlog &#x3D; 65535</li>
<li>net.ipv4.tcp_fin_timeout &#x3D; 10</li>
<li>net.ipv4.tcp_tw_reuse &#x3D; 1</li>
<li>net.ipv4.tcp_tw_recycle &#x3D; 1</li>
</ul>
<ol start="2">
<li>tcp缓冲区参数</li>
</ol>
<ul>
<li>net.core.wmem_default &#x3D; 87380</li>
<li>net.core.wmem_max &#x3D; 16777217</li>
<li>net.core.rmem_default &#x3D; 87380</li>
<li>net.core.rmem_max &#x3D; 16777217</li>
</ul>
<ol>
<li>tcp失效时间参数</li>
</ol>
<ul>
<li>net.ipv4.tcp_keepalive_time &#x3D; 120</li>
<li>net.ipv4.tcp_keepalive_intvl &#x3D; 30</li>
<li>net.ipv4.tcp_keepalive_probes &#x3D; 3</li>
</ul>
<ol>
<li>kernel.shmmax &#x3D; 4294967275</li>
</ol>
<ul>
<li>这个参数应该足够大，以便在一个共享内存段下容纳下整个Innodb缓冲池大小</li>
<li>物理内存减1byte</li>
</ul>
</li>
<li>交换分区<ol>
<li>vm.swappiness &#x3D; 0 除非虚拟内存完全占满了，否则不要交换分区</li>
</ol>
</li>
<li>增加资源限制（&#x2F;etc&#x2F;security&#x2F;limit.conf）<ol>
<li>打开文件数</li>
</ol>
<ul>
<li><ul>
<li>soft nodefile 65535</li>
</ul>
</li>
<li><ul>
<li>hard nodefile 65535</li>
</ul>
</li>
</ul>
</li>
<li>磁盘调度策略<ol>
<li>noop(电梯式调度策略)</li>
</ol>
</li>
</ol>
<h5 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h5><ol>
<li>Ext3&#x2F;4 系统挂载参数（&#x2F;etc&#x2F;fstab）</li>
</ol>
<p>data &#x3D; writeback | ordered | journal</p>
<h5 id="内存的重要性"><a href="#内存的重要性" class="headerlink" title="内存的重要性"></a>内存的重要性</h5><ol>
<li>innodb的数据和索引会缓冲在一个很大的缓冲池中：innodb buffer bool。</li>
<li>案例：数据+索引为18GB，缓冲池大小设置为2GB,4GB,6GB,8GB,10GB,16GB,20GB,22GB 再进行sysbench测试，发现随着缓冲池增大TPS(transaction per second)会线性增长，当增大到20gb，数据库性能有了极大提高。TPS&#x3D;2500</li>
<li>缓冲池命中率应该不低于99%  —-物理磁盘和内存读取比例。<ol>
<li>show global status like ‘innodb%read%<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------------------+----------+</span><br><span class="line"></span><br><span class="line">| Variable_name                         | Value    |</span><br><span class="line"></span><br><span class="line">+---------------------------------------+----------+</span><br><span class="line"></span><br><span class="line">| Innodb_buffer_pool_read_ahead_rnd     | 0        |</span><br><span class="line"></span><br><span class="line">| Innodb_buffer_pool_read_ahead         | 0        |  ---预读的次数</span><br><span class="line"></span><br><span class="line">| Innodb_buffer_pool_read_ahead_evicted | 0        |  ---预读的页，但是没有被读取就从缓冲池中被替换的页的数量，一般来判断预读的效率。</span><br><span class="line"></span><br><span class="line">| Innodb_buffer_pool_read_requests      | 1939677  |  ---从缓冲池中读取页的次数。</span><br><span class="line"></span><br><span class="line">| Innodb_buffer_pool_reads              | 1464     |  ---从物理磁盘读取的页数</span><br><span class="line"></span><br><span class="line">| Innodb_data_pending_reads             | 0        |</span><br><span class="line"></span><br><span class="line">| Innodb_data_read                      | 25203200 |  --共计读入的字节数。</span><br><span class="line"></span><br><span class="line">| Innodb_data_reads                     | 1633     |  --发起读取请求的次数，每次读取可能需要读取多个页。</span><br><span class="line">| Innodb_pages_read                     | 1533     |</span><br><span class="line"></span><br><span class="line">| Innodb_rows_read                      | 482087   |</span><br><span class="line"></span><br><span class="line">+---------------------------------------+----------+</span><br><span class="line"># 缓冲池命中率=Innodb_buffer_pool_read_requests/(Innodb_buffer_pool_read_requests +Innodb_buffer_pool_reads+Innodb_buffer_pool_read_ahead )</span><br><span class="line"># 平均每次读取的字节数=Innodb_pages_read/Innodb_data_reads</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="服务器配置参数"><a href="#服务器配置参数" class="headerlink" title="服务器配置参数"></a>服务器配置参数</h4><p>mysql配置参数作用域</p>
<ul>
<li>全局作用域<ul>
<li>set global 参数名 &#x3D; 参数值</li>
<li>set @@global.参数名&#x3D; 参数值</li>
</ul>
</li>
<li>会话参数<ul>
<li>set [session] 参数名&#x3D; 参数值</li>
<li>set @@session.参数名&#x3D; 参数值</li>
</ul>
</li>
</ul>
<h5 id="内存配置参数"><a href="#内存配置参数" class="headerlink" title="内存配置参数"></a>内存配置参数</h5><ul>
<li>确定可以使用的内存的上限</li>
<li>确定mysql 的每个连接使用的内存<ul>
<li>sort_buffer_size（每个排序都要）</li>
<li>join_buffer_size (每个join都分配)</li>
<li>read_buffer_size()</li>
<li>read_rnd_buffer_size()</li>
</ul>
</li>
<li>确定需要为操作系统保留多少内存</li>
<li>如何为缓冲池分配内存<ul>
<li>Innodb_buffer_pool_size</li>
<li>总内存-（每个线程所需要的内存*连接数）-系统保留的内存</li>
<li>key_buffer_size (myisam)</li>
</ul>
</li>
</ul>
<h5 id="IO相关配置参数"><a href="#IO相关配置参数" class="headerlink" title="IO相关配置参数"></a>IO相关配置参数</h5><h6 id="Innodb-i-x2F-0相关配置"><a href="#Innodb-i-x2F-0相关配置" class="headerlink" title="Innodb i&#x2F;0相关配置"></a>Innodb i&#x2F;0相关配置</h6><ol>
<li>Innodb_log_file_size</li>
<li>Innodb_log_files_in_group</li>
<li>事务日志总大小 &#x3D; Innodb_log_file_size * Innodb_log_files_in_group</li>
<li>Innodb_log_buffer_size  (1s记录)</li>
<li>Innodb_flush_method &#x3D; O_DIRECT</li>
<li>Innodb_file_per_table &#x3D; 1</li>
<li>Innodb_doublewrite &#x3D; 1</li>
<li>innodb_flush_log_at_trx_commit 【建议 2】</li>
</ol>
<ul>
<li>默认为1，可选值如下：<ul>
<li>如果innodb_flush_log_at_trx_commit设置为 0：log buffer将每秒一次地写入log file中，并且log file的flush(刷到磁盘)操作同时进行.该模式下，在事务提交的时候，不会主动触发写入磁盘的操作; （mysqld进程奔溃）</li>
<li>如果innodb_flush_log_at_trx_commit设置为 1：每次事务提交时MySQL都会把log buffer的数据写入log file，并且flush(刷到磁盘)中去;</li>
<li>如果innodb_flush_log_at_trx_commit设置为 2：每次事务提交时MySQL都会把log buffer的数据写入log file，但是flush(刷到磁盘)操作并不会同时进行。该模式下,MySQL会每秒执行一次flush(刷到磁盘)操作。 (操作系统奔溃，系统掉电)</li>
</ul>
</li>
</ul>
<h5 id="安全相关配置参数"><a href="#安全相关配置参数" class="headerlink" title="安全相关配置参数"></a>安全相关配置参数</h5><ol>
<li>expire_logs_days 指定binlog 自动清理天数</li>
<li>max_allowed_packet 控制可接收最大包的大小</li>
</ol>
<h5 id="其他参数配置"><a href="#其他参数配置" class="headerlink" title="其他参数配置"></a>其他参数配置</h5><ol>
<li>sync_binlog	 控制mysql如何向磁盘刷新binlog</li>
<li>max_connection(最大连接数)</li>
</ol>
<h5 id="mysql参数优化"><a href="#mysql参数优化" class="headerlink" title="mysql参数优化"></a>mysql参数优化</h5><h6 id="Innodb的可用缓存参数：innodb-buffer-pool-size"><a href="#Innodb的可用缓存参数：innodb-buffer-pool-size" class="headerlink" title="Innodb的可用缓存参数：innodb_buffer_pool_size"></a>Innodb的可用缓存参数：innodb_buffer_pool_size</h6><ul>
<li>缓冲池是保存innodb表、索引和其他辅助缓冲区的缓存数据的内存区域</li>
<li>理论上最大可以设置为服务器总内存的50%~75%，默认缓冲池大小为128MB</li>
<li>设置越大的值，当然比设置小的值的写入性能更好</li>
</ul>
<ol>
<li>配置的innodb_buffer_pool_size是否合适？<ol>
<li>通过分析InnoDB缓冲池的性能来验证。</li>
</ol>
</li>
</ol>
<p>可以使用以下公式计算InnoDB缓冲池性能：<br>Performance &#x3D; innodb_buffer_pool_reads &#x2F; innodb_buffer_pool_read_requests * 100<br>innodb_buffer_pool_reads：表示InnoDB缓冲池无法满足的请求数。需要从磁盘中读取。<br>innodb_buffer_pool_read_requests：表示从内存中读取逻辑的请求数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">show status like <span class="string">&#x27;innodb_buffer_pool_read%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Innodb_buffer_pool_read_ahead_rnd	0</span><br><span class="line">Innodb_buffer_pool_read_ahead	14</span><br><span class="line">Innodb_buffer_pool_read_ahead_evicted	0</span><br><span class="line">Innodb_buffer_pool_read_requests	20938</span><br><span class="line">Innodb_buffer_pool_reads	1324</span><br><span class="line"></span><br><span class="line">Performance = 1324 / 20938 * 100 = 6.323431082242812</span><br><span class="line">意味着InnoDB可以满足缓冲池本身的大部分请求。从磁盘完成读取的百分比非常小。因此无需增加innodb_buffer_pool_size值</span><br></pre></td></tr></table></figure>
<h6 id="Innodb的并发线程数：innodb-thread-concurrency"><a href="#Innodb的并发线程数：innodb-thread-concurrency" class="headerlink" title="Innodb的并发线程数：innodb_thread_concurrency"></a>Innodb的并发线程数：innodb_thread_concurrency</h6><ul>
<li>故名思意，控制并发线程数，理论上线程数越多当然会写入越快。当然也不能设置过大官方建议是CPU核数的两倍左右最合适。</li>
</ul>
<h6 id="配置参数参考"><a href="#配置参数参考" class="headerlink" title="配置参数参考"></a>配置参数参考</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">port=3306 </span><br><span class="line">serverid=1 </span><br><span class="line">socket=/tmp/mysql.sock  </span><br><span class="line">skip-locking #避免MySQL的外部锁定，减少出错几率增强稳定性。  </span><br><span class="line">skip-name-resolve #禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求！  </span><br><span class="line">back_log=384</span><br><span class="line">key_buffer_size=256M </span><br><span class="line">max_allowed_packet=4M </span><br><span class="line">thread_stack=256K</span><br><span class="line">table_cache=128K </span><br><span class="line">sort_buffer_size=6M </span><br><span class="line">read_buffer_size=4M</span><br><span class="line">read_rnd_buffer_size=16M </span><br><span class="line">join_buffer_size=8M </span><br><span class="line">myisam_sort_buffer_size=64M </span><br><span class="line">table_cache=512 </span><br><span class="line">thread_cache_size=64 </span><br><span class="line">query_cache_size=64M</span><br><span class="line">tmp_table_size=256M </span><br><span class="line">max_connections=768 </span><br><span class="line">max_connect_errors = 10000000</span><br><span class="line">wait_timeout = 10 </span><br><span class="line">thread_concurrency = 8 #该参数取值为服务器逻辑CPU数量*2，在本例中，服务器有2颗物理CPU，而每颗物理CPU又支持H.T超线程，所以实际取值为4*2=8  </span><br><span class="line">skip-networking #开启该选项可以彻底关闭MySQL的TCP/IP连接方式，如果WEB服务器是以远程连接的方式访问MySQL数据库服务器则不要开启该选项！否则将无法正常连接！  </span><br><span class="line">table_cache=1024</span><br><span class="line">innodb_additional_mem_pool_size=4M #默认为2M</span><br><span class="line">innodb_flush_log_at_trx_commit=1</span><br><span class="line">innodb_log_buffer_size=2M #默认为1M  </span><br><span class="line">innodb_thread_concurrency=8 #你的服务器CPU有几个就设置为几。建议用默认一般为8  </span><br><span class="line">tmp_table_size=64M #默认为16M，调到64-256最挂</span><br><span class="line">thread_cache_size=120 query_cache_size=32M</span><br></pre></td></tr></table></figure>

<h4 id="数据库结构设计"><a href="#数据库结构设计" class="headerlink" title="数据库结构设计"></a>数据库结构设计</h4><h5 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h5><p>减少数据冗余，节约空间</p>
<h5 id="数据库设计步骤："><a href="#数据库设计步骤：" class="headerlink" title="数据库设计步骤："></a>数据库设计步骤：</h5><ul>
<li>需求分析：设计存储需求 </li>
<li>逻辑设计：设计数据库逻辑结构</li>
<li>物理设计：表结构设计</li>
</ul>
<h5 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h5><ul>
<li>第一范：数据列不可以拆分</li>
<li>第二范：非主键列不存在对主键列的部分依赖</li>
<li>第三范：表中的列不存在对非主键列的传递依赖 （通常会冗余数据）</li>
</ul>
<p>表的结构更简单、优雅，表的逻辑和条理性更强，并且使用三范式可以很大程度的减少表中的冗余数据，很好的节省了数据库的存储资源<br>范式化设计的优点：</p>
<ul>
<li>可以尽量的减少数据冗余，数据表更新快体积小</li>
<li>范式化的更新操作比反范式化更快</li>
<li>范式化的表通常比反范式化更小</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于查询需要对多个表进行关联（导致性能降低）</li>
<li>更难进行索引优化</li>
</ul>
<p>反范式化优点：</p>
<ul>
<li>可以减少表的关联</li>
<li>可以更好的进行索引优化</li>
</ul>
<p>缺点：</p>
<ul>
<li>存在数据冗余及数据维护的异常</li>
<li>对数据的修改需要更多的成本</li>
</ul>
<h5 id="数据库表设计规范"><a href="#数据库表设计规范" class="headerlink" title="数据库表设计规范"></a>数据库表设计规范</h5><h6 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h6><ul>
<li>表名、字段名必须使用小写字母或者数字，禁止使用数字开头，禁止使用拼音，并且一般不使用英文缩写。</li>
<li>主键索引名为pk_字段名；唯一索引名为uk_字段名；普通索引名则为idx_字段名。</li>
</ul>
<h6 id="合适的字段类型"><a href="#合适的字段类型" class="headerlink" title="合适的字段类型"></a>合适的字段类型</h6><ul>
<li>尽可能选择存储空间小的字段类型，就好像数字类型的，从tinyint、smallint、int、bigint从左往右开始选择</li>
<li>小数类型如金额，则选择 decimal，禁止使用 float 和 double。</li>
<li>推荐优先使用datetime类型来保存日期和时间，因为存储范围更大，且跟时区无关。</li>
<li>如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</li>
<li>varchar是可变长字符串，不预先分配存储空间，长度不要超过5000。</li>
<li>如果存储的值太大，建议字段类型修改为text，同时抽出单独一张表，用主键与之对应。</li>
<li>尽可能使用not null定义字段,null可能使用带来不必要的错误，但不会影响索引<ul>
<li>e.g 表 id|name|mobile  name有null数据，mobile没有，id主键  数据10行，其中2行中name为null</li>
<li>count 丢失 <ul>
<li>select count(name) from table;    result &#x3D; 8</li>
<li>select count(id) from table; result &#x3D; 10;</li>
</ul>
</li>
<li>distinct 数据丢失<ul>
<li>select count(dinstinct name,mobile) from table;  result &#x3D; 8</li>
</ul>
</li>
<li>select 数据丢失<ul>
<li>select * from table where name !&#x3D;”java” order by id;  </li>
<li>null 行数据不会被统计</li>
<li>select * from table where name !&#x3D;”java” or isnull(name) order by id;  正确写法</li>
</ul>
</li>
<li>导致空指针异常</li>
<li>增加查询难度</li>
</ul>
</li>
<li>同一表中，所有varchar字段的长度加起来，不能大于65535. 如果有这样的需求，请使用TEXT&#x2F;LONGTEXT 类型。</li>
</ul>
<h6 id="主键设计要合理"><a href="#主键设计要合理" class="headerlink" title="主键设计要合理"></a>主键设计要合理</h6><ul>
<li>主键设计最好不要与业务逻辑有所关联。有些业务上的字段，比如身份证，虽然是唯一的，一些开发者喜欢用它来做主键，但是不是很建议哈。主键最好是毫无意义的一串独立不重复的数字，比如UUID，又或者Auto_increment自增的主键，或者是雪花算法生成的主键等等;</li>
</ul>
<h6 id="创建高性能索引"><a href="#创建高性能索引" class="headerlink" title="创建高性能索引"></a>创建高性能索引</h6><ul>
<li>索引也不要建得太多，一般单表索引个数不要超过5个。因为创建过多的索引，会降低写得速度。</li>
<li>区分度不高的字段，不能加索引，如性别等</li>
<li>索引创建完后，还是要注意避免索引失效的情况，如使用mysql的内置函数，会导致索引失效的</li>
<li>索引过多的话，可以通过联合索引的话方式来优化。然后的话，索引还有一些规则，如覆盖索引，最左匹配原则等等。。</li>
</ul>
<h6 id="优先考虑逻辑删除，而不是物理删除"><a href="#优先考虑逻辑删除，而不是物理删除" class="headerlink" title="优先考虑逻辑删除，而不是物理删除"></a>优先考虑逻辑删除，而不是物理删除</h6><h6 id="为什么推荐用逻辑删除，不推荐物理删除呢？"><a href="#为什么推荐用逻辑删除，不推荐物理删除呢？" class="headerlink" title="为什么推荐用逻辑删除，不推荐物理删除呢？"></a>为什么推荐用逻辑删除，不推荐物理删除呢？</h6><ul>
<li>为什么不推荐使用物理删除，因为恢复数据很困难</li>
<li>物理删除会使自增主键不再连续</li>
<li>核心业务表 的数据不建议做物理删除，只适合做状态变更。</li>
</ul>
<h6 id="每个表都需要添加这几个通用字段如主键、create-time、modifed-time等"><a href="#每个表都需要添加这几个通用字段如主键、create-time、modifed-time等" class="headerlink" title="每个表都需要添加这几个通用字段如主键、create_time、modifed_time等"></a>每个表都需要添加这几个通用字段如主键、create_time、modifed_time等</h6><h6 id="一张表的字段不宜过多"><a href="#一张表的字段不宜过多" class="headerlink" title="一张表的字段不宜过多"></a>一张表的字段不宜过多</h6><p>如果一张表的字段过多，表中保存的数据可能就会很大，查询效率就会很低。因此，一张表不要设计太多字段哈，如果业务需求，实在需要很多字段，可以把一张大的表，拆成多张小的表，它们的主键相同即可。</p>
<h6 id="不搞外键关联，一般都在代码维护"><a href="#不搞外键关联，一般都在代码维护" class="headerlink" title="不搞外键关联，一般都在代码维护"></a>不搞外键关联，一般都在代码维护</h6><h6 id="一般都选择INNODB存储引擎"><a href="#一般都选择INNODB存储引擎" class="headerlink" title="一般都选择INNODB存储引擎"></a>一般都选择INNODB存储引擎</h6><h6 id="选择合适统一的字符集。"><a href="#选择合适统一的字符集。" class="headerlink" title="选择合适统一的字符集。"></a>选择合适统一的字符集。</h6><p>数据库库、表、开发程序等都需要统一字符集，通常中英文环境用utf8。<br>MySQL支持的字符集有utf8、utf8mb4、GBK、latin1等。</p>
<ul>
<li>utf8：支持中英文混合场景，国际通过，3个字节长度</li>
<li>utf8mb4:   完全兼容utf8，4个字节长度，一般存储emoji表情需要用到它。</li>
<li>GBK ：支持中文，但是不支持国际通用字符集，2个字节长度</li>
<li>latin1：MySQL默认字符集，1个字节长度</li>
</ul>
<h6 id="大字段"><a href="#大字段" class="headerlink" title="大字段"></a>大字段</h6><h6 id="考虑是否需要分库分表"><a href="#考虑是否需要分库分表" class="headerlink" title="考虑是否需要分库分表"></a>考虑是否需要分库分表</h6><h4 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h4><h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><ol>
<li>建立Mysql服务器基准线</li>
<li>模拟比当前系统更高的负载，以找出系统的扩展瓶颈</li>
<li>测试不同硬件、软件和操作系统的配置</li>
<li>证明新硬件设备是否配置正确</li>
</ol>
<h5 id="如何进行基础测试"><a href="#如何进行基础测试" class="headerlink" title="如何进行基础测试"></a>如何进行基础测试</h5><ol>
<li>对整个系统进行基准测试</li>
<li>单独对mysql进行基准测试</li>
</ol>
<h5 id="常见指标"><a href="#常见指标" class="headerlink" title="常见指标"></a>常见指标</h5><ol>
<li>TPS</li>
<li>QPS</li>
<li>响应时间</li>
<li>并发量</li>
</ol>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><h5 id="问题sql筛查"><a href="#问题sql筛查" class="headerlink" title="问题sql筛查"></a>问题sql筛查</h5><ul>
<li>检查慢查询日志<ul>
<li>show variables like ‘%slow_query_log%’;</li>
</ul>
</li>
<li>开启慢查询<ul>
<li>set global slow_query_log&#x3D;on;</li>
</ul>
</li>
<li>慢查日志判断标准(默认查询大于10s的sql)<ul>
<li>show variables like ‘long_query_time’;</li>
<li>select sleep(11); 休眠11s测试</li>
</ul>
</li>
</ul>
<h5 id="大事务的影响"><a href="#大事务的影响" class="headerlink" title="大事务的影响"></a>大事务的影响</h5><p>数据库连接池撑爆<br>锁太多资源<br>执行时间长，主从延迟<br>回滚时间长<br>容易导致死锁</p>
<h5 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h5><p>当需要分页操作时，通常会使用LIMIT加上偏移量的办法实现，同时加上合适的ORDER BY字句。如果有对应的索引，通常效率会不错，否则，MySQL需要做大量的文件排序操作。<br> 一个常见的问题是当偏移量非常大的时候，比如：LIMIT 10000 20这样的查询，MySQL需要查询10020条记录然后只返回20条记录，前面的10000条都将被抛弃，这样的代价非常高。<br>优化这种查询一个最简单的办法就是尽可能的使用覆盖索引扫描，而不是查询所有的列。然后根据需要做一次关联查询再返回所有的列。对于偏移量很大时，这样做的效率会提升非常大。考虑下面的查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film.film_id,film.description</span><br><span class="line"><span class="keyword">FROM</span> film <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> film_id <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title LIMIT <span class="number">50</span>,<span class="number">5</span></span><br><span class="line"></span><br><span class="line">) <span class="keyword">AS</span> tmp <span class="keyword">USING</span>(film_id);</span><br></pre></td></tr></table></figure>
<p>这里的延迟关联将大大提升查询效率，让MySQL扫描尽可能少的页面，获取需要访问的记录后在根据关联列回原表查询所需要的列。</p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="什么是死锁？怎么解决？"><a href="#什么是死锁？怎么解决？" class="headerlink" title="什么是死锁？怎么解决？"></a>什么是死锁？怎么解决？</h4><p>死锁是两个或多个事务在同一个资源上相互占用，并请求锁定对方的资源，从而导致循环的现象<br>常见的解决死锁的方法</p>
<ul>
<li>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li>
<li>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</li>
<li>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</li>
</ul>
<h4 id="如何避免死锁产生？"><a href="#如何避免死锁产生？" class="headerlink" title="如何避免死锁产生？"></a>如何避免死锁产生？</h4><ul>
<li>合理的设计索引结构，使业务SQL在执行时能通过索引定位到具体的几行数据，减小锁的粒度。</li>
<li>业务允许的情况下，也可以将隔离级别调低，因为级别越低，锁的限制会越小。</li>
<li>调整业务SQL的逻辑顺序，较大、耗时较长的事务尽量放在特定时间去执行（如凌晨对账…）。</li>
<li>尽可能的拆分业务的粒度，一个业务组成的大事务，尽量拆成多个小事务，缩短一个事务持有锁的时间。</li>
<li>如果没有强制性要求，就尽量不要手动在事务中获取排他锁，否则会造成一些不必要的锁出现，增大产生死锁的几率。</li>
</ul>
<h4 id="MVCC机制是否彻底解决了幻读问题呢？"><a href="#MVCC机制是否彻底解决了幻读问题呢？" class="headerlink" title="MVCC机制是否彻底解决了幻读问题呢？"></a>MVCC机制是否彻底解决了幻读问题呢？</h4><p>先上定论，MVCC并没有彻底解决幻读问题，在一种奇葩的情况下依旧会出现问题，先来看例子：<br>– 开启一个事务T1 begin; – 查询表中 ID&gt;10 的数据 SELECT * FROM <code>zz_users</code> where user_id &gt; 10; Empty set (0.01 sec) 复制代码<br>因为用户表中不存在ID&gt;10的数据，所以T1查询时没有结果，再继续往下看。<br>– 再开启一个事务T2 begin; – 向表中插入一条 ID&#x3D;11 的数据 INSERT INTO <code>zz_users</code> VALUES(11,”墨竹”,”男”,”2222”,”2022-10-07 23:24:36”); – 提交事务T2 commit; 复制代码<br>此时T2事务插入一条ID&#x3D;11的数据并提交，此时再回到T1事务中：<br>– 在T1事务中，再次查询表中 ID&gt;10 的数据 SELECT * FROM <code>zz_users</code> where user_id &gt; 10; Empty set (0.01 sec) 复制代码<br>结果很明显，依旧未查询到ID&gt;10的数据，因为这里是通过第一次生成的快照文件在读，所以读不到T2新增的“幻影数据”，似乎没问题对嘛？接着往下看：<br>– 在T1事务中，对 ID&#x3D;11 的数据进行修改 UPDATE <code>zz_users</code> SET <code>password</code> &#x3D; “1111” where <code>user_id</code> &#x3D; 11; – 在T1事务中，再次查询表中 ID&gt;10 的数据 SELECT * FROM <code>zz_users</code> where user_id &gt; 10; +———+———–+———-+———-+———————+ | user_id | user_name | user_sex | password | register_time       | +———+———–+———-+———-+———————+ |      11 | 墨竹      | 男       | 1111     | 2022-10-07 23:24:36 | +———+———–+———-+———-+———————+ 复制代码<br>嗯？！？？此时会发现，T1事务中又能查询到ID&#x3D;11的这条幻影记录了，这是啥原因导致的呢？因为我们在T1中修改了ID&#x3D;11的数据，在<a target="_blank" rel="noopener" href="https://juejin.cn/post/7155359629050904584">《MVCC机制原理剖析》</a>中曾讲过MVCC通过快照检索数据的过程，这里T1根据原本的快照文件检索数据时，因为发现ID&#x3D;11这条数据上的隐藏列trx_id是自己，因此就能看到这条幻影数据了。<br>实际上这个问题有点四不像，可以理解成幻读问题，也可以理解成是不可重复读问题，总之不管怎么说，就是MVCC机制存在些许问题！但这种情况线下一般不会发生，毕竟不同事务之间都是互不相知的，在一个事务中，不可能会去主动修改一条“不存在”的记录。<br>但如若你实在不放心，想要彻底杜绝任何风险的出现，那就直接将事务隔离级别调整到Serializable即可。</p>
<h4 id="数据库的乐观锁和悲观锁是什么？怎么实现的？"><a href="#数据库的乐观锁和悲观锁是什么？怎么实现的？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？怎么实现的？"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h4><ol>
<li>悲观锁，多个事务在同一资源上竞争，需要加锁控制</li>
<li>乐观锁    多个事务不存在竞争，如果存在使用cas版本比较</li>
</ol>
<h4 id="一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15-16-17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15-？"><a href="#一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15-16-17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15-？" class="headerlink" title="一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？"></a>一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</h4><p>如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID 记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；<br>如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。</p>
<h4 id="为什么MySQL-索引中用B-tree，不用B-tree-或者其他树，为什么不用-Hash-索引"><a href="#为什么MySQL-索引中用B-tree，不用B-tree-或者其他树，为什么不用-Hash-索引" class="headerlink" title="为什么MySQL 索引中用B+tree，不用B-tree 或者其他树，为什么不用 Hash 索引"></a>为什么MySQL 索引中用B+tree，不用B-tree 或者其他树，为什么不用 Hash 索引</h4><h4 id="聚簇索引-x2F-非聚簇索引，MySQL-索引底层实现，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？"><a href="#聚簇索引-x2F-非聚簇索引，MySQL-索引底层实现，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？" class="headerlink" title="聚簇索引&#x2F;非聚簇索引，MySQL 索引底层实现，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？"></a>聚簇索引&#x2F;非聚簇索引，MySQL 索引底层实现，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</h4><h4 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么?"></a>使用索引查询一定能提高查询的性能吗？为什么?</h4><h4 id="何谓事务？"><a href="#何谓事务？" class="headerlink" title="何谓事务？"></a>何谓事务？</h4><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<h4 id="查询中哪些情况不会使用索引？"><a href="#查询中哪些情况不会使用索引？" class="headerlink" title="查询中哪些情况不会使用索引？"></a>查询中哪些情况不会使用索引？</h4><ul>
<li>在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</li>
<li>存储引擎不能使用索引中范围条件右边的列</li>
<li>is null ,is not null 也无法使用索引</li>
<li>like “xxxx%” 是可以用到索引的，like “%xxxx” 则不行(like “%xxx%” 同理)。like以通配符开头(‘%abc…’)索引失效会变成全表扫描的操作，</li>
<li>字符串不加单引号索引失效</li>
<li>少用or，用它来连接时会索引失效</li>
<li>&lt;，&lt;&#x3D;，&#x3D;，&gt;，&gt;&#x3D;，BETWEEN，IN 可用到索引，&lt;&gt;，not in ，!&#x3D; 则不行，会导致全表扫描</li>
</ul>
<h5 id="查询操作方法需要使用事务吗？"><a href="#查询操作方法需要使用事务吗？" class="headerlink" title="查询操作方法需要使用事务吗？"></a>查询操作方法需要使用事务吗？</h5><h4 id="order-by-是怎样排序的？怎么优化？"><a href="#order-by-是怎样排序的？怎么优化？" class="headerlink" title="order by 是怎样排序的？怎么优化？"></a>order by 是怎样排序的？怎么优化？</h4><h5 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h5><ol>
<li>查询语句有 in 多个属性时，SQL 执行是否有排序过程？</li>
<li>分页 limit 过大，导致大量排序。咋办？</li>
<li>索引存储顺序与 order by 不一致，如何优化？</li>
<li>没有 where 条件，order by 字段需要加索引吗</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/16/My-New-Post/" rel="prev" title="My New Post">
      <i class="fa fa-chevron-left"></i> My New Post
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/24/hello-world/" rel="next" title="Hello World">
      Hello World <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">体系架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%B1%82"><span class="nav-number">1.1.</span> <span class="nav-text">网络连接层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-number">1.1.1.</span> <span class="nav-text">客户端连接池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%95%B0"><span class="nav-number">1.1.2.</span> <span class="nav-text">数据库连接数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.1.3.</span> <span class="nav-text">数据库线程池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%B1%82"><span class="nav-number">1.2.</span> <span class="nav-text">系统服务层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.1.</span> <span class="nav-text">SQL接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-number">1.2.2.</span> <span class="nav-text">解析器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8"><span class="nav-number">1.2.3.</span> <span class="nav-text">优化器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98-amp-%E7%BC%93%E5%86%B2"><span class="nav-number">1.2.4.</span> <span class="nav-text">缓存&amp;缓冲</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%B1%82"><span class="nav-number">1.3.</span> <span class="nav-text">存储引擎层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Innodb"><span class="nav-number">1.3.1.</span> <span class="nav-text">Innodb</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="nav-number">1.3.1.1.1.</span> <span class="nav-text">缓冲池</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%89%B9%E6%80%A7-ACID"><span class="nav-number">1.3.1.2.1.</span> <span class="nav-text">特性(ACID)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%97%A5%E5%BF%97"><span class="nav-number">1.3.1.2.2.</span> <span class="nav-text">日志</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.3.1.2.3.</span> <span class="nav-text">隔离级别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E4%BA%A7%E7%94%9F%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.1.2.4.</span> <span class="nav-text">并发事务产生问题</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82"><span class="nav-number">1.4.</span> <span class="nav-text">文件系统层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E6%9D%BF%E5%9D%97"><span class="nav-number">1.4.1.</span> <span class="nav-text">日志板块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%9D%BF%E5%9D%97"><span class="nav-number">1.4.2.</span> <span class="nav-text">数据板块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">优化分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">SQL执行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E6%9D%A1SQL%E6%89%A7%E8%A1%8C%E5%89%8D%E4%BC%9A%E7%BB%8F%E5%8E%86%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">2.1.1.</span> <span class="nav-text">一条SQL执行前会经历的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">数据库连接池的必要性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SQL%E6%89%A7%E8%A1%8C%E5%89%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E6%83%85"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">SQL执行前会发生的事情</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F"><span class="nav-number">2.1.2.</span> <span class="nav-text">一条SQL语句在数据库中是如何执行的？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E6%9D%A1%E6%9F%A5%E8%AF%A2SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">一条查询SQL的执行过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E6%9D%A1%E5%86%99%E5%85%A5SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">一条写入SQL的执行过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E6%9D%A1SQL%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%88%90%E5%90%8E%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E7%9A%84%EF%BC%9F"><span class="nav-number">2.1.3.</span> <span class="nav-text">一条SQL执行完成后是如何返回的？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E7%B1%BB%E5%9E%8B%E7%9A%84SQL%E8%BF%94%E5%9B%9E"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">读类型的SQL返回</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%99%E7%B1%BB%E5%9E%8B%E7%9A%84SQL%E8%BF%94%E5%9B%9E"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">写类型的SQL返回</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.</span> <span class="nav-text">MVCC概念以及底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MVCC%E8%83%BD%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E5%90%97"><span class="nav-number">2.2.1.</span> <span class="nav-text">MVCC能解决幻读吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#select-%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="nav-number">2.2.2.</span> <span class="nav-text">select 快照读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="nav-number">2.2.3.</span> <span class="nav-text">当前读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E4%BE%9D%E8%B5%96%E7%9A%84%E4%B8%89%E4%B8%AA%E7%BB%84%E4%BB%B6%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="nav-number">2.2.4.</span> <span class="nav-text">MVCC多版本并发控制依赖的三个组件重要概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVCC%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.5.</span> <span class="nav-text">MVCC实现多版本并发控制的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8BMVCC%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.6.</span> <span class="nav-text">不同隔离级别下MVCC实现并发控制的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B"><span class="nav-number">2.2.6.1.</span> <span class="nav-text">RC隔离级别下</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B"><span class="nav-number">2.2.6.2.</span> <span class="nav-text">RR隔离级别下</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LBCC"><span class="nav-number">2.3.</span> <span class="nav-text">LBCC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E7%9A%84%E9%94%81%E5%88%86%E7%B1%BB"><span class="nav-number">2.3.1.</span> <span class="nav-text">MySQL的锁分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">锁的模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%81%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">锁算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E6%A8%A1%E5%BC%8F-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">锁的模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">共享锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%92%E5%AE%83%E9%94%81"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">排它锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">意向锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.3.</span> <span class="nav-text">锁的算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%8C%BA%E9%97%B4"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">锁的区间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">记录锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%B4%E9%9A%99%E9%94%81"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">间隙锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%B4%E9%94%AE%E9%94%81"><span class="nav-number">2.3.3.4.</span> <span class="nav-text">临键锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">2.3.4.</span> <span class="nav-text">用法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#select-for-update"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">select for update</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">死锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">2.4.</span> <span class="nav-text">索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%88%86%E6%9E%90"><span class="nav-number">2.5.</span> <span class="nav-text">执行计划分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#EXPLAIN%E4%B8%AD%E7%9A%84%E5%88%97"><span class="nav-number">2.5.1.</span> <span class="nav-text">EXPLAIN中的列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#id"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">id</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#select-type"><span class="nav-number">2.5.1.2.</span> <span class="nav-text">select_type</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#table"><span class="nav-number">2.5.1.3.</span> <span class="nav-text">table</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#type"><span class="nav-number">2.5.1.4.</span> <span class="nav-text">type</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#possible-keys"><span class="nav-number">2.5.1.5.</span> <span class="nav-text">possible_keys</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#key"><span class="nav-number">2.5.1.6.</span> <span class="nav-text">key</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Extra"><span class="nav-number">2.5.1.7.</span> <span class="nav-text">Extra</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="nav-number">2.6.</span> <span class="nav-text">性能优化建议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2%E9%85%8D%E7%BD%AE"><span class="nav-number">2.6.1.</span> <span class="nav-text">系统层面配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E4%BB%B6"><span class="nav-number">2.6.1.1.</span> <span class="nav-text">服务器硬件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#CPU%E8%B5%84%E6%BA%90%EF%BC%8864%E4%BD%8D%EF%BC%8C%E4%B8%BB%E9%A2%91%EF%BC%8C%E6%A0%B8%E5%BF%83%E6%95%B0%EF%BC%89"><span class="nav-number">2.6.1.1.1.</span> <span class="nav-text">CPU资源（64位，主频，核心数）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Memory%E8%B5%84%E6%BA%90%EF%BC%88%E4%B8%BB%E9%A2%91%E9%AB%98%EF%BC%8C%E5%AE%B9%E9%87%8F%E5%A4%A7%EF%BC%89"><span class="nav-number">2.6.1.1.2.</span> <span class="nav-text">Memory资源（主频高，容量大）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E9%85%8D%E7%BD%AE"><span class="nav-number">2.6.1.1.3.</span> <span class="nav-text">磁盘配置</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.6.1.2.</span> <span class="nav-text">服务器系统</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#centos%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0"><span class="nav-number">2.6.1.2.1.</span> <span class="nav-text">centos系统参数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.6.1.3.</span> <span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="nav-number">2.6.1.4.</span> <span class="nav-text">内存的重要性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-number">2.6.2.</span> <span class="nav-text">服务器配置参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-number">2.6.2.1.</span> <span class="nav-text">内存配置参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IO%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-number">2.6.2.2.</span> <span class="nav-text">IO相关配置参数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Innodb-i-x2F-0%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="nav-number">2.6.2.2.1.</span> <span class="nav-text">Innodb i&#x2F;0相关配置</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-number">2.6.2.3.</span> <span class="nav-text">安全相关配置参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="nav-number">2.6.2.4.</span> <span class="nav-text">其他参数配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mysql%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96"><span class="nav-number">2.6.2.5.</span> <span class="nav-text">mysql参数优化</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Innodb%E7%9A%84%E5%8F%AF%E7%94%A8%E7%BC%93%E5%AD%98%E5%8F%82%E6%95%B0%EF%BC%9Ainnodb-buffer-pool-size"><span class="nav-number">2.6.2.5.1.</span> <span class="nav-text">Innodb的可用缓存参数：innodb_buffer_pool_size</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Innodb%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BA%BF%E7%A8%8B%E6%95%B0%EF%BC%9Ainnodb-thread-concurrency"><span class="nav-number">2.6.2.5.2.</span> <span class="nav-text">Innodb的并发线程数：innodb_thread_concurrency</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E5%8F%82%E8%80%83"><span class="nav-number">2.6.2.5.3.</span> <span class="nav-text">配置参数参考</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.6.3.</span> <span class="nav-text">数据库结构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84"><span class="nav-number">2.6.3.1.</span> <span class="nav-text">设计目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="nav-number">2.6.3.2.</span> <span class="nav-text">数据库设计步骤：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F"><span class="nav-number">2.6.3.3.</span> <span class="nav-text">数据库范式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="nav-number">2.6.3.4.</span> <span class="nav-text">数据库表设计规范</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="nav-number">2.6.3.4.1.</span> <span class="nav-text">命名规范</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%88%E9%80%82%E7%9A%84%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.6.3.4.2.</span> <span class="nav-text">合适的字段类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1%E8%A6%81%E5%90%88%E7%90%86"><span class="nav-number">2.6.3.4.3.</span> <span class="nav-text">主键设计要合理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95"><span class="nav-number">2.6.3.4.4.</span> <span class="nav-text">创建高性能索引</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%89%A9%E7%90%86%E5%88%A0%E9%99%A4"><span class="nav-number">2.6.3.4.5.</span> <span class="nav-text">优先考虑逻辑删除，而不是物理删除</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E7%94%A8%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4%EF%BC%8C%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%89%A9%E7%90%86%E5%88%A0%E9%99%A4%E5%91%A2%EF%BC%9F"><span class="nav-number">2.6.3.4.6.</span> <span class="nav-text">为什么推荐用逻辑删除，不推荐物理删除呢？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%AF%8F%E4%B8%AA%E8%A1%A8%E9%83%BD%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E8%BF%99%E5%87%A0%E4%B8%AA%E9%80%9A%E7%94%A8%E5%AD%97%E6%AE%B5%E5%A6%82%E4%B8%BB%E9%94%AE%E3%80%81create-time%E3%80%81modifed-time%E7%AD%89"><span class="nav-number">2.6.3.4.7.</span> <span class="nav-text">每个表都需要添加这几个通用字段如主键、create_time、modifed_time等</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%80%E5%BC%A0%E8%A1%A8%E7%9A%84%E5%AD%97%E6%AE%B5%E4%B8%8D%E5%AE%9C%E8%BF%87%E5%A4%9A"><span class="nav-number">2.6.3.4.8.</span> <span class="nav-text">一张表的字段不宜过多</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%8D%E6%90%9E%E5%A4%96%E9%94%AE%E5%85%B3%E8%81%94%EF%BC%8C%E4%B8%80%E8%88%AC%E9%83%BD%E5%9C%A8%E4%BB%A3%E7%A0%81%E7%BB%B4%E6%8A%A4"><span class="nav-number">2.6.3.4.9.</span> <span class="nav-text">不搞外键关联，一般都在代码维护</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E9%83%BD%E9%80%89%E6%8B%A9INNODB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">2.6.3.4.10.</span> <span class="nav-text">一般都选择INNODB存储引擎</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%BB%9F%E4%B8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E3%80%82"><span class="nav-number">2.6.3.4.11.</span> <span class="nav-text">选择合适统一的字符集。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%A7%E5%AD%97%E6%AE%B5"><span class="nav-number">2.6.3.4.12.</span> <span class="nav-text">大字段</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%80%83%E8%99%91%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="nav-number">2.6.3.4.13.</span> <span class="nav-text">考虑是否需要分库分表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="nav-number">2.6.4.</span> <span class="nav-text">基准测试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84"><span class="nav-number">2.6.4.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%9F%BA%E7%A1%80%E6%B5%8B%E8%AF%95"><span class="nav-number">2.6.4.2.</span> <span class="nav-text">如何进行基础测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E6%8C%87%E6%A0%87"><span class="nav-number">2.6.4.3.</span> <span class="nav-text">常见指标</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">2.6.5.</span> <span class="nav-text">查询优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%98sql%E7%AD%9B%E6%9F%A5"><span class="nav-number">2.6.5.1.</span> <span class="nav-text">问题sql筛查</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%A7%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">2.6.5.2.</span> <span class="nav-text">大事务的影响</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E5%8C%96LIMIT%E5%88%86%E9%A1%B5"><span class="nav-number">2.6.5.3.</span> <span class="nav-text">优化LIMIT分页</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">2.7.</span> <span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-number">2.7.1.</span> <span class="nav-text">什么是死锁？怎么解决？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%EF%BC%9F"><span class="nav-number">2.7.2.</span> <span class="nav-text">如何避免死锁产生？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVCC%E6%9C%BA%E5%88%B6%E6%98%AF%E5%90%A6%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3%E4%BA%86%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F"><span class="nav-number">2.7.3.</span> <span class="nav-text">MVCC机制是否彻底解决了幻读问题呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-number">2.7.4.</span> <span class="nav-text">数据库的乐观锁和悲观锁是什么？怎么实现的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E5%BC%A0%E8%A1%A8%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%9C%89ID%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%EF%BC%8C%E5%BD%93insert%E4%BA%8617%E6%9D%A1%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%88%A0%E9%99%A4%E4%BA%86%E7%AC%AC15-16-17%E6%9D%A1%E8%AE%B0%E5%BD%95%EF%BC%8C%E5%86%8D%E6%8A%8AMysql%E9%87%8D%E5%90%AF%EF%BC%8C%E5%86%8Dinsert%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%EF%BC%8C%E8%BF%99%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84ID%E6%98%AF18%E8%BF%98%E6%98%AF15-%EF%BC%9F"><span class="nav-number">2.7.5.</span> <span class="nav-text">一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88MySQL-%E7%B4%A2%E5%BC%95%E4%B8%AD%E7%94%A8B-tree%EF%BC%8C%E4%B8%8D%E7%94%A8B-tree-%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E6%A0%91%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8-Hash-%E7%B4%A2%E5%BC%95"><span class="nav-number">2.7.6.</span> <span class="nav-text">为什么MySQL 索引中用B+tree，不用B-tree 或者其他树，为什么不用 Hash 索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95-x2F-%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%8CMySQL-%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E5%AD%98%E6%94%BE%E7%9A%84%E6%98%AF%E6%95%B0%E6%8D%AE%E8%BF%98%E6%98%AF%E6%8C%87%E5%90%91%E6%95%B0%E6%8D%AE%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9C%B0%E6%96%B9%EF%BC%9F"><span class="nav-number">2.7.7.</span> <span class="nav-text">聚簇索引&#x2F;非聚簇索引，MySQL 索引底层实现，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E4%B8%80%E5%AE%9A%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%80%A7%E8%83%BD%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">2.7.8.</span> <span class="nav-text">使用索引查询一定能提高查询的性能吗？为什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E8%B0%93%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="nav-number">2.7.9.</span> <span class="nav-text">何谓事务？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E4%B8%AD%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E4%BC%9A%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">2.7.10.</span> <span class="nav-text">查询中哪些情况不会使用索引？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%E5%90%97%EF%BC%9F"><span class="nav-number">2.7.10.1.</span> <span class="nav-text">查询操作方法需要使用事务吗？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#order-by-%E6%98%AF%E6%80%8E%E6%A0%B7%E6%8E%92%E5%BA%8F%E7%9A%84%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">2.7.11.</span> <span class="nav-text">order by 是怎样排序的？怎么优化？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-1"><span class="nav-number">2.7.11.1.</span> <span class="nav-text">面试题</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Kevin Chen"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Kevin Chen</p>
  <div class="site-description" itemprop="description">bbbbbb</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kevin Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
